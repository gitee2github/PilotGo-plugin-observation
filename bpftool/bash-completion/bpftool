# bpftool(8) bash completion                               -*- shell-script -*-
#
# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
# Copyright (C) 2017-2018 Netronome Systems, Inc.
#
# Author: Quentin Monnet <quentin.monnet@netronome.com>

# Takes a list of words in argument; each one of them is added to COMPREPLY if
# it is not already present on the command line. Returns no value.
_bpftool_once_attr()
{
    local w idx found
    for w in $*; do
        found=0
        for (( idx=3; idx < ${#words[@]}-1; idx++ )); do
            if [[ $w == ${words[idx]} ]]; then
                found=1
                break
            fi
        done
        [[ $found -eq 0 ]] && \
            COMPREPLY+=( $( compgen -W "$w" -- "$cur" ) )
    done
}

# Takes a list of words as argument; if any of those words is present on the
# command line, return 0. Otherwise, return 1.
_bpftool_search_list()
{
    local w idx
    for w in $*; do
        for (( idx=3; idx < ${#words[@]}-1; idx++ )); do
            [[ $w == ${words[idx]} ]] && return 0
        done
    done
    return 1
}

# Takes a list of words in argument; adds them all to COMPREPLY if none of them
# is already present on the command line. Returns no value.
_bpftool_one_of_list()
{
    _bpftool_search_list $* && return 1
    COMPREPLY+=( $( compgen -W "$*" -- "$cur" ) )
}

_bpftool_get_map_ids()
{
    COMPREPLY+=( $( compgen -W "$( bpftool -jp map  2>&1 | \
        command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ) )
}

# Takes map type and adds matching map ids to the list of suggestions.
_bpftool_get_map_ids_for_type()
{
    local type="$1"
    COMPREPLY+=( $( compgen -W "$( bpftool -jp map  2>&1 | \
        command grep -C2 "$type" | \
        command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ) )
}

_bpftool_get_map_names()
{
    COMPREPLY+=( $( compgen -W "$( bpftool -jp map  2>&1 | \
        command sed -n 's/.*"name": \(.*\),$/\1/p' )" -- "$cur" ) )
}

# Takes map type and adds matching map names to the list of suggestions.
_bpftool_get_map_names_for_type()
{
    local type="$1"
    COMPREPLY+=( $( compgen -W "$( bpftool -jp map  2>&1 | \
        command grep -C2 "$type" | \
        command sed -n 's/.*"name": \(.*\),$/\1/p' )" -- "$cur" ) )
}

_bpftool_get_prog_ids()
{
    COMPREPLY+=( $( compgen -W "$( bpftool -jp prog 2>&1 | \
        command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ) )
}

_bpftool_get_prog_tags()
{
    COMPREPLY+=( $( compgen -W "$( bpftool -jp prog 2>&1 | \
        command sed -n 's/.*"tag": "\(.*\)",$/\1/p' )" -- "$cur" ) )
}

_bpftool_get_prog_names()
{
    COMPREPLY+=( $( compgen -W "$( bpftool -jp prog 2>&1 | \
        command sed -n 's/.*"name": "\(.*\)",$/\1/p' )" -- "$cur" ) )
}

_bpftool_get_btf_ids()
{
    COMPREPLY+=( $( compgen -W "$( bpftool -jp btf 2>&1 | \
        command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ) )
}

_bpftool_get_link_ids()
{
    COMPREPLY+=( $( compgen -W "$( bpftool -jp link 2>&1 | \
        command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ) )
}

_bpftool_get_obj_map_names()
{
    local obj

    obj=$1

    maps=$(objdump -j maps -t $obj 2>/dev/null | \
        command awk '/g     . maps/ {print $NF}')

    COMPREPLY+=( $( compgen -W "$maps" -- "$cur" ) )
}

_bpftool_get_obj_map_idxs()
{
    local obj

    obj=$1

    nmaps=$(objdump -j maps -t $obj 2>/dev/null | grep -c 'g     . maps')

    COMPREPLY+=( $( compgen -W "$(seq 0 $((nmaps - 1)))" -- "$cur" ) )
}

_sysfs_get_netdevs()
{
    COMPREPLY+=( $( compgen -W "$( ls /sys/class/net 2>/dev/null )" -- \
        "$cur" ) )
}

# Retrieve type of the map that we are operating on.
_bpftool_map_guess_map_type()
{
    local keyword ref
    for (( idx=3; idx < ${#words[@]}-1; idx++ )); do
        case "${words[$((idx-2))]}" in
            lookup|update)
                keyword=${words[$((idx-1))]}
                ref=${words[$((idx))]}
                ;;
            push)
                printf "stack"
                return 0
                ;;
            enqueue)
                printf "queue"
                return 0
                ;;
        esac
    done
    [[ -z $ref ]] && return 0

    local type
    type=$(bpftool -jp map show $keyword $ref | \
        command sed -n 's/.*"type": "\(.*\)",$/\1/p')
    [[ -n $type ]] && printf $type
}

_bpftool_map_update_get_id()
{
    local command="$1"

    # Is it the map to update, or a map to insert into the map to update?
    # Search for "value" keyword.
    local idx value
    for (( idx=7; idx < ${#words[@]}-1; idx++ )); do
        if [[ ${words[idx]} == "value" ]]; then
            value=1
            break
        fi
    done
    if [[ $value -eq 0 ]]; then
        case "$command" in
            push)
                _bpftool_get_map_ids_for_type stack
                ;;
            enqueue)
                _bpftool_get_map_ids_for_type queue
                ;;
            *)
                _bpftool_get_map_ids
                ;;
        esac
        return 0
    fi

    # Id to complete is for a value. It can be either prog id or map id. This
    # depends on the type of the map to update.
    local type=$(_bpftool_map_guess_map_type)
    case $type in
        array_of_maps|hash_of_maps)
            _bpftool_get_map_ids
            return 0
            ;;
        prog_array)
            _bpftool_get_prog_ids
            return 0
            ;;
        *)
            return 0
            ;;
    esac
}